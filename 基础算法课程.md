# 1.二分查找

### 1. 力扣 704 

######  --非递归

```
var search = function(nums, target) {
    let left = 0, right = nums.length -1;

    while(left<=right){
    
        //我写的是right+left除2的形式，有问题
        let mid = left + Math.floor((right-left)/2);
        
        if(nums[mid] === target){
            return mid;
        }else if(nums[mid] < target){
        
        //不知道为什么 我的是 left==mid而这里+1了
            left = mid + 1;
            
        }else{
            right = mid - 1;
        }
    }
    return -1;
};
```

###### 

为什么之前出现死循环?

在最后一次循环时，
如果向下取整，left可能会一直和mid相等，导致left值一直不变，进入死循环，所以，left不能赋值为mid;
如果向上取整，right可能会一直和mid相等，导致right值一直不变，进入死循环，所以，right不能赋值为mid;



**使用二分查找，指针天然的向左收缩**

###### --递归

```
let search=function(nums,left,right,target){
	return binary(nums,left,right,target);
}

function binary(nums,left,right,target){
	if(left>right){
		return -1;
	}
	let mid=left+Math.floor((right-left)/2);
	while(left<=right){
		if(nums[mid]===target){
			return mid;
		}
		if(nums[mid]<target){
			return binary(nums,mid+1,left,target);
		}else{
			return binary(nums,right,mid-1,target);
		}
	}
}
```

### 2. 力扣 34

```
var searchRange = function(nums, target) {
    let leftResult=findLeft(nums,target);
    let rightResult=findRight(nums,target);
    if(rightResult==-1){
        return[leftResult,leftResult]
    }
    if(leftResult==-1){
        return[rightResult,rightResult]
    }
    return [leftResult,rightResult]

};
function findLeft(nums,target) {
    let left=0;
    let right=nums.length-1;
    let index=-1;
    while (left<=right) {
        let mid=left+Math.floor((right-left)/2);
        if(mid==left||mid==right){
            if(nums[mid]===target){
                index=mid;
            }
            return index;
        }
        if(nums[mid]===target){
            right=mid;
            index=mid;
        }else if(nums[mid]<target){
            left=mid;
        }else{
            right=mid;
        }

    }
    return index
}

function findRight(nums,target) {
    let left=0;
    let right=nums.length-1;
    let index=-1;
    while (left<=right) {
        let mid=left+Math.ceil((right-left)/2);
        if(mid==left||mid==right){
            if(nums[mid]===target){
                index=mid;
            }
            return index;
        }
        if(nums[mid]===target){
            left=mid;
            index=mid;
        }else if(nums[mid]<target){
            left=mid;
        }else{
            right=mid;
        }

    }
    return index
}
```

### 3.力扣 153

```
function getMin(nums){
    let left=0;
    let right=nums.length-1;
    while(left<right){
        let mid=left+Math.floor((right-left)/2);
        if(nums[mid]<nums[right]){
            right=mid;
        }else{
            left=mid+1
        }
    }
    return nums[left]
}

console.log(getMin([4,5,6,1,2]))
```

# 2.基础排序算法

### 冒泡排序

```
let bubble=function(nums){
	let len=nums.length;
	for(let i=0;i<len-1;i++){
		for(let j=i+1;j<len;j++){
			if(nums[i]>nums[j]){
				[nums[i],nums[j]]=[nums[j],nums[i]]
			}
		}
	}
	return nums;
}
```



### 选择排序

```
let choose=function(nums){
	let len=nums.length;
	for(let i=0;i<len-1;i++){
		let min=i;
		for(let j=i+1;j<len;j++){
			if(nums[j]<nums[min]){
				min=j;
			}
		}
		[nums[i],nums[min]]=[nums[min],nums[i]]
	}
}
```

所以选择排序和冒泡排序就特么是一样的，只不过冒泡是选择的过程

### 插入排序

#### 实现1

```
let insert_1=function(nums){
	let len=nums.length;
	for(let i=1;i<len;i++){
		for(let j=i;j>0;j--){
			if(nums[j-1]>nums[j]){
				[nums[j-1],nums[j]]=[nums[j],nums[j-1]];
			}
		}
	}
	return nums;
}
```



#### 实现2

```
let insert_2=function(nums){
	let len=nums.length;
	let preIndex,current;
	for(let i=1;i<len;i++){
		current=nums[i];
		preIndex=i-1;
		while(preIndex>=0&&current<nums[preIndex]){
			nums[preIndex+1]=nums[preIndex];
			preIndex--;
		}
		nums[preIndex+1]=current;
	}
	return nums;
}
```



### 希尔排序

```
let shell=function(nums){
	let len=nums.length;
	let current;
	let gap=Math.floor(len/2);
	while(gap!=0){
		for(let i=gap;i<len;i++){
			current=nums[i];
			for(let j=i-gap;j>=0&&current<nums[j];j--){
				nums[j+gap]=nums[j];
			}
			nums[j+gap]=current;
		}
		gap=Math.floor(gap/2);
	}
	return nums;
}
//改为相似的
let shell=function(nums){
	let len=nums.length;
	let current,preIndex;
	let gap=Math.floor(len/2);
	while(gap!=0){
		for(let i=gap;i<len;i++){
			current=nums[i];
			preIndex=i-1;
			while(preIndex>=0&&current<nums[preIndex]){
				[nums[preIndex+1],nums[preIndex]]=[nums[preIndex],nums[preIndex-1]];
				preIndex--;
			}
			nums[preIndex+1]=current;
		}
		gap=Math.floor(gap/2);
	}
	return nums;
}
```



# 3.高级排序算法

### 归并排序

```
function merge(left,right){
	let result=[];
	while(left.length>0&&right.length>0){
		if(left[0]>right[0]){
			result.push(left.shift());
		}else{
			result.push(right.shift());
		}
	}
	return result.concat(left).concat(right);
}

function mergeSort(nums){
	if(nums.length<=1) return nums;
	let middle=Math.floor(nums.length/2);
	let left=nums.slice(0,middle);
	let right=nums.slice(middle);
	return merge(mergeSort(left),mergeSort(right));
}
```

**练习：数组中的逆序对**

```
function get(nums) {
    let total=0;
    let merge=function(left,right){
        let result=[];
        while(left.length>0&&right.length>0){
            if(left[0]>right[0]){
                total+=right.length；
                result.push(left.shift());
            }else{
                result.push(right.shift());
            }
        }
        return result.concat(left).concat(right);
    }

    let mergeSort=function(nums){
        if(nums.length<=1) return nums;
        let middle=Math.floor(nums.length/2);
        let left=nums.slice(0,middle);
        let right=nums.slice(middle);
        return merge(mergeSort(left),mergeSort(right));
    }
    mergeSort(nums)
    return nums.length>1?total:0;
}
```

就在原有的归并排序算法里的一步，当左边的最小的比右边

```
if(left[0]>right[0]){
    total+=right.length
    result.push(left.shift());
}else{
    result.push(right.shift());
}
```

**练习：计算右侧小于当前元素的个数**



### 快速排序

```
function quickSort(arr){
	if(arr.length<=1) return arr;
	let pivotIndex=Math.floor(arr.length/2);
	let pivot=arr.splice(pivotIndex,1)[0];
	let left=[];
	let right=[];
	for(let i=0;i<arr.length;i++){
		if(arr[i]<pivot){
			left.push(arr[i]);
		}else{
			right.push(arr[i]);
		}
	}
	return quickSort(left).concat([pivot],quickSort(right));
}
```

**练习：删除排序数组中的重复项**

```
var removeDuplicates = function(nums) {
    let left=0,right=1;
    if(nums.length<=1) return nums;
    while(typeof nums[right] != 'undefined'){
        if(nums[left]==nums[right]){
            nums.splice(right,1);
            left--;
            right--;
        }
        left++;
        right++;
    }
    return nums.length;
};
```

**练习：删除排序数组中的重复项 II**

```
var removeDuplicates = function(nums) {
    if(nums.length<=1) return nums;
    let index=0;
    let temp=null;;
    let same=1;
    while(typeof nums[index] != 'undefined'){
        if(temp==null){
            temp=nums[index];
            same=1;
        }else {
            if(nums[index]==temp){
                same++;
                if(same>2){
                    nums.splice(index,1);
                    index--;
                }
            }else{
                same=1;
                temp=nums[index];
            }
        }
        index++
    }
    return nums;
};
```



练习：根据字符出现频率排序

```
var frequencySort = function(s) {
    let resource=s.split('').sort().join('');
    let arr=resource.match(/(.)\1*/g);
    let result={};
    for(let i=0;i<arr.length;i++){
        if(result[arr[i].length]){
            result[arr[i].length].push(arr[i]);
        }else{
            result[arr[i].length]=[arr[i]];
        }
    }
    let list=Object.keys(result).sort((a,b)=>{
        return Number(b)>Number(a);
    });
    let output='';
    for(let i=list.length-1;i>=0;i--){
        output+=result[list[i]].join('')
    }
    return list;
};
```









# 4.非比较排序算法(pass)

### 计数算法

### 基数排序

### 桶排序

### 排序方法总结





# 5. 数组里常见的两类算法

### 滑动窗口

### 滑动窗口经典问题

**例题：「力扣」第 3 题：无重复字符的最长子串**

子串（substring）：在原始数组中一定连续；
子序列（subsequeue）：在原始数组中不一定连续，只需要这些子序列中的元素保持在原始数组中的相对顺序。



```js
let str = 'abca'  s = 3 
//因为无重复字符的最长子串是 "abc"，所以其长度为3。
let str = 'bbbb'  s = 1
//因为无重复字符的最长子串是 "b"，所以其长度为1。

//现在利用滑动窗口来解决这个问题.
//第一什么是滑动窗口,滑动窗口就是利用队列的思想,将队列的元素与目标元素进行比较.
//如果队列没有目标元素,就将目标元素填充到队列中,如果有目标元素那就不继续滑动窗口
//将队列元素返回.这就是滑动窗口的思想.
function check(str) {
    let arr = [] // 定义一个队列 ,也就是说滑动窗口 
    for (let i = 0; i<str.length; i++;){   // for循环遍历字符串下标
    	let index = arr.indexOf(str[i])     // 定义一个变量用于判断
     	if (index !== -1 ) {
           arr.splice(0,index+1)        // 如果arr数组含有这个元素 那么就删除掉这个元素之前
    	} 
        arr.push(str.charAt(i))  // 将元素推入队列之中
        max = Math.max(arr.length, max)     // 比较长度
  	}
	return max      
}
```

知乎上找的，非常好理解



**例题：最小覆盖子串**



**练习：长度最小的子数组**

**练习：找到字符串中所有字母异位词**

**练习：字符串的排列**

**练习：替换后的最长重复字符**







### 双指针

### 双指针经典问题
