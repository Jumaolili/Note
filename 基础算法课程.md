# 1.二分查找

### 1. 力扣 704 

######  --非递归

```javascript
var search = function(nums, target) {
    let left = 0, right = nums.length -1;

    while(left<=right){
    
        //我写的是right+left除2的形式，有问题
        let mid = left + Math.floor((right-left)/2);
        
        if(nums[mid] === target){
            return mid;
        }else if(nums[mid] < target){
        
        //不知道为什么 我的是 left==mid而这里+1了
            left = mid + 1;
            
        }else{
            right = mid - 1;
        }
    }
    return -1;
};
```

###### 

为什么之前出现死循环?

在最后一次循环时，
如果向下取整，left可能会一直和mid相等，导致left值一直不变，进入死循环，所以，left不能赋值为mid;
如果向上取整，right可能会一直和mid相等，导致right值一直不变，进入死循环，所以，right不能赋值为mid;



**使用二分查找，指针天然的向左收缩**

###### --递归

```
let search=function(nums,left,right,target){
	return binary(nums,left,right,target);
}

function binary(nums,left,right,target){
	if(left>right){
		return -1;
	}
	let mid=left+Math.floor((right-left)/2);
	while(left<=right){
		if(nums[mid]===target){
			return mid;
		}
		if(nums[mid]<target){
			return binary(nums,mid+1,left,target);
		}else{
			return binary(nums,right,mid-1,target);
		}
	}
}
```

### 2. 力扣 34

```
var searchRange = function(nums, target) {
    let leftResult=findLeft(nums,target);
    let rightResult=findRight(nums,target);
    if(rightResult==-1){
        return[leftResult,leftResult]
    }
    if(leftResult==-1){
        return[rightResult,rightResult]
    }
    return [leftResult,rightResult]

};
function findLeft(nums,target) {
    let left=0;
    let right=nums.length-1;
    let index=-1;
    while (left<=right) {
        let mid=left+Math.floor((right-left)/2);
        if(mid==left||mid==right){
            if(nums[mid]===target){
                index=mid;
            }
            return index;
        }
        if(nums[mid]===target){
            right=mid;
            index=mid;
        }else if(nums[mid]<target){
            left=mid;
        }else{
            right=mid;
        }

    }
    return index
}

function findRight(nums,target) {
    let left=0;
    let right=nums.length-1;
    let index=-1;
    while (left<=right) {
        let mid=left+Math.ceil((right-left)/2);
        if(mid==left||mid==right){
            if(nums[mid]===target){
                index=mid;
            }
            return index;
        }
        if(nums[mid]===target){
            left=mid;
            index=mid;
        }else if(nums[mid]<target){
            left=mid;
        }else{
            right=mid;
        }

    }
    return index
}
```

### 3.力扣 153

```
function getMin(nums){
    let left=0;
    let right=nums.length-1;
    while(left<right){
        let mid=left+Math.floor((right-left)/2);
        if(nums[mid]<nums[right]){
            right=mid;
        }else{
            left=mid+1
        }
    }
    return nums[left]
}

console.log(getMin([4,5,6,1,2]))
```

# 2.基础排序算法

### 冒泡排序

```
let bubble=function(nums){
	let len=nums.length;
	for(let i=0;i<len-1;i++){
		for(let j=i+1;j<len;j++){
			if(nums[i]>nums[j]){
				[nums[i],nums[j]]=[nums[j],nums[i]]
			}
		}
	}
	return nums;
}
```



### 选择排序

```
let choose=function(nums){
	let len=nums.length;
	for(let i=0;i<len-1;i++){
		let min=i;
		for(let j=i+1;j<len;j++){
			if(nums[j]<nums[min]){
				min=j;
			}
		}
		[nums[i],nums[min]]=[nums[min],nums[i]]
	}
}
```

所以选择排序和冒泡排序就特么是一样的，只不过冒泡是选择的过程

### 插入排序

#### 实现1

```
let insert_1=function(nums){
	let len=nums.length;
	for(let i=1;i<len;i++){
		for(let j=i;j>0;j--){
			if(nums[j-1]>nums[j]){
				[nums[j-1],nums[j]]=[nums[j],nums[j-1]];
			}
		}
	}
	return nums;
}
```



#### 实现2

```
let insert_2=function(nums){
	let len=nums.length;
	let preIndex,current;
	for(let i=1;i<len;i++){
		current=nums[i];
		preIndex=i-1;
		while(preIndex>=0&&current<nums[preIndex]){
			nums[preIndex+1]=nums[preIndex];
			preIndex--;
		}
		nums[preIndex+1]=current;
	}
	return nums;
}
```



### 希尔排序

```
let shell=function(nums){
	let len=nums.length;
	let current;
	let gap=Math.floor(len/2);
	while(gap!=0){
		for(let i=gap;i<len;i++){
			current=nums[i];
			for(let j=i-gap;j>=0&&current<nums[j];j--){
				nums[j+gap]=nums[j];
			}
			nums[j+gap]=current;
		}
		gap=Math.floor(gap/2);
	}
	return nums;
}
//改为相似的
let shell=function(nums){
	let len=nums.length;
	let current,preIndex;
	let gap=Math.floor(len/2);
	while(gap!=0){
		for(let i=gap;i<len;i++){
			current=nums[i];
			preIndex=i-1;
			while(preIndex>=0&&current<nums[preIndex]){
				nums[preIndex+1]=nums[preIndex]
				preIndex--;
			}
			nums[preIndex+1]=current;
		}
		gap=Math.floor(gap/2);
	}
	return nums;
}
```



# 3.高级排序算法

### 归并排序

```
function merge(left,right){
	let result=[];
	while(left.length>0&&right.length>0){
		if(left[0]>right[0]){
			result.push(left.shift());
		}else{
			result.push(right.shift());
		}
	}
	return result.concat(left).concat(right);
}

function mergeSort(nums){
	if(nums.length<=1) return nums;
	let middle=Math.floor(nums.length/2);
	let left=nums.slice(0,middle);
	let right=nums.slice(middle);
	return merge(mergeSort(left),mergeSort(right));
}
```

**练习：数组中的逆序对**

```
function get(nums) {
    let total=0;
    let merge=function(left,right){
        let result=[];
        while(left.length>0&&right.length>0){
            if(left[0]>right[0]){
                total+=right.length；
                result.push(left.shift());
            }else{
                result.push(right.shift());
            }
        }
        return result.concat(left).concat(right);
    }

    let mergeSort=function(nums){
        if(nums.length<=1) return nums;
        let middle=Math.floor(nums.length/2);
        let left=nums.slice(0,middle);
        let right=nums.slice(middle);
        return merge(mergeSort(left),mergeSort(right));
    }
    mergeSort(nums)
    return nums.length>1?total:0;
}
```

就在原有的归并排序算法里的一步，当左边的最小的比右边

```
if(left[0]>right[0]){
    total+=right.length
    result.push(left.shift());
}else{
    result.push(right.shift());
}
```

**练习：计算右侧小于当前元素的个数**



### 快速排序

```
function quickSort(arr){
	if(arr.length<=1) return arr;
	let pivotIndex=Math.floor(arr.length/2);
	let pivot=arr.splice(pivotIndex,1)[0];
	let left=[];
	let right=[];
	for(let i=0;i<arr.length;i++){
		if(arr[i]<pivot){
			left.push(arr[i]);
		}else{
			right.push(arr[i]);
		}
	}
	return quickSort(left).concat([pivot],quickSort(right));
}
```

**练习：删除排序数组中的重复项**

```
var removeDuplicates = function(nums) {
    let left=0,right=1;
    if(nums.length<=1) return nums;
    while(typeof nums[right] != 'undefined'){
        if(nums[left]==nums[right]){
            nums.splice(right,1);
            left--;
            right--;
        }
        left++;
        right++;
    }
    return nums.length;
};
```

**练习：删除排序数组中的重复项 II**

```
var removeDuplicates = function(nums) {
    if(nums.length<=1) return nums;
    let index=0;
    let temp=null;;
    let same=1;
    while(typeof nums[index] != 'undefined'){
        if(temp==null){
            temp=nums[index];
            same=1;
        }else {
            if(nums[index]==temp){
                same++;
                if(same>2){
                    nums.splice(index,1);
                    index--;
                }
            }else{
                same=1;
                temp=nums[index];
            }
        }
        index++
    }
    return nums;
};
```



练习：根据字符出现频率排序

```javascript
var frequencySort = function(s) {
    let resource=s.split('').sort().join('');
    let arr=resource.match(/(.)\1*/g);
    let result={};
    for(let i=0;i<arr.length;i++){
        if(result[arr[i].length]){
            result[arr[i].length].push(arr[i]);
        }else{
            result[arr[i].length]=[arr[i]];
        }
    }
    let list=Object.keys(result).sort((a,b)=>{
        return Number(b)>Number(a);
    });
    let output='';
    for(let i=list.length-1;i>=0;i--){
        output+=result[list[i]].join('')
    }
    return list;
};
```









# 4.非比较排序算法(pass)

### 计数算法

### 基数排序

### 桶排序

### 排序方法总结





# 5. 数组里常见的两类算法

### 滑动窗口

### 滑动窗口经典问题

**例题：「力扣」第 3 题：无重复字符的最长子串**

子串（substring）：在原始数组中一定连续；
子序列（subsequeue）：在原始数组中不一定连续，只需要这些子序列中的元素保持在原始数组中的相对顺序。



```js
let str = 'abca'  s = 3 
//因为无重复字符的最长子串是 "abc"，所以其长度为3。
let str = 'bbbb'  s = 1
//因为无重复字符的最长子串是 "b"，所以其长度为1。

//现在利用滑动窗口来解决这个问题.
//第一什么是滑动窗口,滑动窗口就是利用队列的思想,将队列的元素与目标元素进行比较.
//如果队列没有目标元素,就将目标元素填充到队列中,如果有目标元素那就不继续滑动窗口
//将队列元素返回.这就是滑动窗口的思想.
function check(str) {
    let arr = [] // 定义一个队列 ,也就是说滑动窗口 
    for (let i = 0; i<str.length; i++;){   // for循环遍历字符串下标
    	let index = arr.indexOf(str[i])     // 定义一个变量用于判断
     	if (index !== -1 ) {
           arr.splice(0,index+1)        // 如果arr数组含有这个元素 那么就删除掉这个元素之前
    	} 
        arr.push(str.charAt(i))  // 将元素推入队列之中
        max = Math.max(arr.length, max)     // 比较长度
  	}
	return max      
}
```

知乎上找的，非常好理解



**例题：最小覆盖子串**



**练习：长度最小的子数组**

**练习：找到字符串中所有字母异位词**

**练习：字符串的排列**

**练习：替换后的最长重复字符**







### 双指针

### 双指针经典问题



# 6. 链表

### 链表问题概述

链表和数组

动态和静态结构

链表：单向链表，双向链表，循环链表

LRU缓存结构和双向链表

链表和数组在内存中的状态

```javascript
function LinkedList() {
    this.head=null;
    this.insert=function(node) {
        if(this.head==null){
            this.head=node;
        }else{
            let currentNode=this.head;
            while (currentNode.next!=null) {
                currentNode=currentNode.next;
            }
            currentNode.next=node;
        }
    };
    this.remove=function(data) {
        if(this.head==null) {
            return false;
        }
        let preNode=null;
        let currentNode=this.head;
        let nextNode=currentNode.next;
        if(currentNode.data==data){
            this.head=nextNode;
            return
        }
        while (currentNode.data!=data) {
            if(currentNode.next==null){
                return false;
            }
            preNode=currentNode;
            currentNode=currentNode.next;
        }
        preNode.next=nextNode;
        currentNode.next=null;
    };
    this.update=function(data,newData) {
        let currentNode=this.head;
        while (currentNode!=null) {
            if(currentNode.data===data){
                currentNode.data=newData;
                return true;
            }
            currentNode=currentNode.next;
        }
        return false;

    };
    this.display=function() {
        let currentNode=this.head;
        let result=[]
        while (currentNode!=null) {
            result.push(currentNode);
            currentNode=currentNode.next
        }
        console.log(result)
    };
}
```



### 解决链表中的指针指向问题

**例题：「力扣」第 206 题：反转链表**

```javascript
//使用循环
function reverseLink(link) {
    //定义滑动窗口
    let test=[];
    //当前
    let currentNode=link.head;
    let nextNode=currentNode.next;
    //暂存nextNode的nextNode，因为需要对nextNode进行next改变，就找不到它的下一个
    let temp=null;
    //每一个nextNode都可能是最后一个节点，到时候需要变为link的head
    let lastNode=null;
    // 只有一个节点
    if(nextNode==null){
        return false;
    }
    // >=两个节点
    test=[currentNode]; //推入窗口
    while (nextNode!=null) {
        test.push(nextNode);//推入窗口
        //由于next的改变会让我们找不到后面的节点，需要缓存
        temp=nextNode.next;
        lastNode=nextNode;
        //只有原link第一个需要指向null，其他的都会在后一步改变next
        if(test[0]==link.head){
            test[0].next=null;
        }
        test[1].next=test[0];
        //缓存的作用体现
        nextNode=temp;
        test.shift();//弹出第一个
    }
    //此时未进入while循环，因为循环最后nextNode指向null，而我们用lastNode缓存了前一次循环的nextNode(最后一个)
    link.head=lastNode;
}

```



**完成「力扣」第 92 题：反转链表 II；**

```javascript

//反转某一段的链表
function reverseBetweenLink(linkedList,leftIndex,rightIndex){
    //找出那一段生成一个新链表
    //反转
    //把生成的新链表的head接回去
    let left=null,right=null;
    let leftNode=null,rightNode=null;
    //计数
    let index=1;
    let currentNode=linkedList.head;
    let nextNode=currentNode.next;
    //一个节点
    if(nextNode==null) return false;
    //>=两个节点
    while (currentNode!=null&&left==null) {
        if(index==leftIndex-1){
            if(currentNode.next!=null){
                left=currentNode;
                leftNode=currentNode.next;
            }else{
                return false;
            }
        }
        index++;
        currentNode=currentNode.next;
    }
    //找到了左端点，此时位于左端点
    while (rightNode==null) {
        index++
        currentNode=currentNode.next;
        if(index==rightIndex){
            rightNode=currentNode;
            right=currentNode.next;
        }
    }
    left.next=null;
    rightNode.next=null;
    //创建一个新的链表
    let reversedLink=new LinkedList();
    reversedLink.head=leftNode;
    rightNode.next=null;
    reverseLink(reversedLink);
    left.next=reversedLink.head;
    leftNode.next=right;
}
```



**完成「力扣」第 203 题：移除链表元素。**

```
function removeAll(linkedList,data) {
    //找出节点
    let currentNode=linkedList.head;
    let nextNode=currentNode.next;
    //只有一个节点
    if(nextNode==null){
        if(currentNode.data==data){
            linkedList.head=null;
            return true;
        }else{
            return false;
        }
    }
    //>= 2个节点
    let preNode=null;
    while (currentNode!=null) {
        if(currentNode.data==data){
            if(preNode!=null){
                currentNode=currentNode.next;
                preNode.next=currentNode;
            }else{
                currentNode=currentNode.next;
                linkedList.head=currentNode;
            }
        }else{
            preNode=currentNode;
            currentNode=currentNode.next;
        }
    }
}
```

**完成「力扣」第 24 题：两两交换链表中的节点；**



**完成「力扣」第 25 题：K 个一组翻转链表；**
**完成「力扣」第 143 题：重排链表；**
**完成「力扣」第 328 题：奇偶链表。**
**完成「力扣」第 61 题：旋转链表（这个问题不用递归去做）；**
**完成「力扣」第 234 题：回文链表（这个问题做法很多，需留意）；**
**完成「力扣」第 147 题：对链表进行插入排序（这个问题较复杂，需要有点耐心，不用递归去做）。**





### 测试单链表程序

**例题：通过输入数组来创建列表**

```javascript
function linkFactory(nums) {
    if(nums instanceof Array !== true){
        return false;
    }
    let list = new LinkedList();
    let currentNode=null;
    for(let i=0;i<nums.length;i++){
        if(i==0){
            let node = new Node(nums[i]);
            list.head=node;
            currentNode=node;
        }else{
            let node= new Node(nums[i]);
            currentNode.next=node;
            currentNode=node;
        }
    }
    return list;
}
```



### 虚拟头节点

**例题：「力扣」第 19 题：删除链表的倒数第 N 个节点**

```javascript
function removeLast(link,index) {
    let interval=[];
    let currentNode=link.head;
    let preNode=null;
    while (interval.length<index) {
        if(currentNode==null) return false;
        interval.push(currentNode);
        currentNode=currentNode.next;
    }
    //此时currentNode为即将进入窗口的第一个
    while (currentNode!=null) {
        preNode = interval.shift();
        interval.push(currentNode);
        currentNode=currentNode.next;
    }
    preNode.next=interval[1];
    interval[0].next=null;
}
```

**练习：两数相加**

**练习：两数相加 II**

**练习：合并两个有序链表**

**练习：合并 K 个排序链表**

**练习：删除排序链表中的重复元素 II**

**练习：删除排序链表中的重复元素**

**练习：分隔链表**

###### 







### 快慢指针

**例题：删除链表的倒数第 N 个节点**

```

```

**练习：链表的中间结点**

```javascript
//中间节点
function findMiddle(list){
    let slowNode=list.head;
    let quickNode=list.head;
    while (quickNode!=null) {
        //快指针走两步
        quickNode=quickNode.next;
        //走到尽头了
        if(quickNode==null) return slowNode;
        quickNode=quickNode.next;
        if(quickNode==null) return false;
        //慢指针走一步
        slowNode=slowNode.next;
    }
}
```



### 典型问题1：环形链表

**例 1：「力扣」第 142 题：环形链表 II**

```javascript
function isCircle(linkedList) {
    let quickNode=linkedList.head;
    let slowNode=linkedList.head;
    while (quickNode!=null) {
        //快指针移动
        quickNode=quickNode.next;
        if(quickNode==null) return false;
        quickNode=quickNode.next;
        if(quickNode==null) return false;
        //慢指针移动
        slowNode=slowNode.next;
        if(quickNode==slowNode){
            return true;
        }
    }
}

```

**例 2：「力扣」第 141 题：环形链表 II**

```

```



**练习: 使用快慢指针的技巧完成「力扣」第 287 题：寻找重复数。**

```

```





### 典型问题2：相交链表

**例：「力扣」第 160 题：相交链表**

**例题：相交链表**

**练习：设计推特**

```javascript
function Node(user,message) {
    this.user=user;
    this.message=message;
    this.next=null;
}

function LinkedList() {
    this.head=null;
    this.subscribe={};
    this.postTweet=function(userId,postId) {
        let node= new Node(userId,postId);
        //加入
        let preNode=null;
        let currentNode=this.head;
        //<=1 
        if(currentNode==null){
            this.head=node;
            return true;
        }
        //>=2
        while (currentNode!=null) {
            preNode=currentNode;
            currentNode=currentNode.next;
        }
        preNode.next=node;
    };
    this.getNewsFeed=function(userId) {
        let result=[];
        //判断是否有订阅列表
        if(!this.subscribe[userId]){
            this.subscribe[userId]=[];
        }
        let subscribe=this.subscribe[userId];
        let currentNode=this.head;
        while (result.length<10&&currentNode!=null) {
            if(currentNode.message!=null&&(currentNode.user==userId||subscribe.indexOf(currentNode.user)>=0)){
                result.unshift(currentNode.message);
            };
            currentNode=currentNode.next;
        }
        return result;
    };
    this.follow=function(userId,followUser) {
        if(userId==followUser){
            return false;
        }
        if(!this.subscribe[userId]){
            this.subscribe[userId]=[];
        }
        if(this.subscribe[userId].indexOf(followUser)>=0) return false;
        this.subscribe[userId].push(followUser);
    };
    this.unfollow=function(userId,cancelId) {
        if(userId==cancelId){
            return false;
        }
        if(!this.subscribe[userId]){
            this.subscribe[userId]=[];
            return false;
        }
        if(this.subscribe[userId].indexOf(cancelId)<0) return false;
        for(let i=0;i<this.subscribe[userId].length;i++){
            if(this.subscribe[userId][i]==cancelId){
                this.subscribe[userId].splice(i,1);
                return true;
            }
        }
    };
}

```

**练习：LRU 缓存机制**

```javascript
function LRUCache(capacity) {
    this.head=null;
    this.length=0;
    this.capacity=capacity;
};

function Node(key,value) {
    this.key=key;
    this.value=value;
    this.next=null;
}

LRUCache.prototype.get = function(key) {
    //判断是否存在
    //存在 (位置提前，并且拉去value)  ||  不存在 -1
    let newValue=arguments[1]; //接受第二个参数
    let preNode=null;
    let currentNode=this.head;
    while (currentNode!=null) {
        if(currentNode.key==key) {
            //位置提前
            if(preNode!=null){
                //取出
                //找到最后一个节点
                let nextNode=currentNode.next;
                preNode.next=nextNode;

                let lastNode=this.head;
                while (lastNode.next!=null) {
                    lastNode=lastNode.next;
                }
                lastNode.next=currentNode;
                currentNode.next=null;

            }else{
                let nextNode=currentNode.next;
                this.head=nextNode;

                let lastNode=this.head;
                while (lastNode.next!=null) {
                    lastNode=lastNode.next;
                }
                lastNode.next=currentNode;
                currentNode.next=null;
            }
            if(newValue){
                currentNode.value=newValue;
            };
            return currentNode.value;
        }
        preNode=currentNode;
        currentNode=currentNode.next;
    }
    return -1;
};

LRUCache.prototype.put = function(key, value) {
    //判断是否存在
    //存在  ||  不存在
    let preNode=null;
    let currentNode=this.head;
    while (currentNode!=null) {
        if(currentNode.key==key) {
            return this.get(key,value);
        }
        currentNode=currentNode.next;
    }
    if(this.length>=this.capacity){
        //去除链表头部
        //插入
        let node = new Node(key,value);
        let nextNode=currentNode.next;
        this.head=nextNode;
        let lastNode=this.head;
        while (lastNode.next!=null) {
            lastNode=lastNode.next;
        }
        lastNode.next=node;
        this.length++;
    }else{
        //插入
        let node = new Node(key,value);
        let lastNode=this.head;
        if(lastNode==null){
            this.head=node;
            this.length++;
            return true;
        }
        while (lastNode.next!=null) {
            lastNode=lastNode.next;
        }
        lastNode.next=node;
        this.length++;
    }
};
```

**练习：LFU 缓存**

**练习：设计跳表**







# 7.栈与队列

### 动态数组

### 栈：后进先出的数据结构

### 典型问题 1：简化路径

**例题：简化路径**

```javascript
var simplifyPath = function(path) {
    let stack=[];
    let queue=path.split('/')
                  .filter(item=>{
                      return item!='';
                  });
    while (queue.length>0) {
        let item=queue.shift();
        if(item=='..'){
            if(stack.length>0){
                stack.pop();
            }
        }else if(item=='.'){

        }else{
            stack.push(item)
        }
    }
    let result='/'+stack.join('/');
    return result;

};
```

**练习：有效的括号**

```javascript
    while(s.indexOf('{}')>=0||s.indexOf('[]')>=0||s.indexOf('()')>=0){
        s=s
            .replace('[]','')
            .replace('{}','')
            .replace('()','');
    }

    return s.length>0 ? false : true;
```

**练习：逆波兰表达式求值**



```javascript
let stack=[];
    while(tokens.length>0){
        let item=tokens.shift();
        if(!isNaN(Number(item))){
            stack.push(item);
        }else{
            let num_1=stack.pop();
            let num_2=stack.pop();
            let result=eval('('+num_2+')'+item+'('+num_1+')');
            if(result>0){
                result=Math.floor(result);
            }else{
                result=Math.ceil(result);
            }
            stack.push(result);
        }
    }
    return stack[0];
```



### 典型问题 2：去除重复字母

```javascript
var evalRPN = function(str) {
    let local='abcdefghijklmnopqrstuvwxyz';
    let stack=[];
    let queue=str.split('');
    while (queue.length>0) {
        let item=queue.shift();
        if(stack.indexOf(item)>=0){
            //能找到上一个

            let preIndex=stack.indexOf(item);
            //寻找那些字符
            let localIndex=local.indexOf(item)-1;

            if(localIndex+1==0){
                //什么都不做
                //没有寻找必要 aa
            }else if(preIndex==0) {
                for(let i=stack.length-1;i>0;i--){
                    let boss=stack[i];
                    if(local.indexOf(boss)>=0&&local.indexOf(boss)<=i){
                        stack.splice(preIndex,1);
                        stack.push(item);
                        break;
                    }
                }
            }else{
                //前面的上司
                let boss_left=null;
                for(let index=0;index<=localIndex;index++){
                    let searchOne=local[index];
                    let foundIndex=stack.indexOf(searchOne);
                    if(foundIndex<preIndex){
                        boss_left=searchOne;
                        break;
                    }
                }
                //后面的上司
                let boss_right=null;
                let findArea=stack.slice(preIndex+1);
                for(let index=0;index<=localIndex;index++){
                    let searchOne=local[index];
                    let foundIndex=findArea.indexOf(searchOne);
                    if(foundIndex<preIndex){
                        boss_right=searchOne;
                        break;
                    }
                }
                //比较
                if(boss_left==null){
                    stack.splice(preIndex,1);
                    stack.push(item);
                }else if(boss_left!=null&&boss_right!=null&&boss_right<boss_left) {
                    stack.splice(preIndex,1);
                    stack.push(item);
                }
            }
            
        }else{
            stack.push(item);
        }
    }
    return stack;
};

```

26

### 典型问题 3：单调栈

**接雨水**

```javascript
function Rain(arr) {
    //栈
    let stack=[];
    let capacity=0;
    let count=0;
    while (arr.length>0) {
        let height=arr.shift();
        if(stack.length==0){
            stack.push(height)
        }else if(stack[stack.length-1]>=height){
            stack.push(height)
        }else if(stack[stack.length-1]<height){
            //可能形成凹槽
            let run=1;
            while(run==1&&stack[stack.length-1]<height){
                let middle=stack.pop();
                count++;
                let left=stack[stack.length-1];
                if(left==undefined){
                    stack
                        .push(middle)
                        count--;
                        run=0;
                }else if(left>middle){
                    capacity+=(Math.min(height,left)-middle)*count;
                }else {
                    stack
                        .push(middle)
                        count--;
                        run=0;
                }
            }
            stack.push(height);
        }
    }
    return capacity;
}


//上面的有问题
var trap = function(nums) {
    //栈
    let stack=[];
    let capacity=0;
    for(let i=0;i<nums.length;i++){
        if(stack.length==0){
            stack.push(i)
        }else{
            let index=stack[stack.length-1];
            if(nums[index]>=nums[i]){
                stack.push(i)
            }else{
                let run=true;
                while(run==true&&nums[stack[stack.length-1]]<nums[i]){
                    if(stack[stack.length-2]!=undefined&&nums[stack[stack.length-2]]>nums[stack[stack.length-1]]){
                        let pop=stack.pop();
                        let min =Math.min(nums[i],nums[stack[stack.length-1]]);
                        capacity+=(min-nums[pop])*(i-pop);
                    }else{
                        stack.push(i);
                        run=false;
                    }
                }
            }
        }
    }
    return capacity;
}
```



**完成「力扣」第 739 题：每日温度；**

```javascript
var dailyTemperatures = function(nums) {
    let result=new Array(nums.length);
    let stack=[];
    for(let i=0;i<nums.length;i++){
        if(stack.length==0){
            stack.push(i)
        }else{
            let index=stack[stack.length-1];
            if(nums[index]>=nums[i]){
                stack.push(i);
            }else{
                while(nums[stack[stack.length-1]]<nums[i]){
                    let pop=stack.pop();
                    result[pop]=i-pop;
                }
                stack.push(i)
            }
        }
    }
    for(let i=0;i<result.length;i++){
        if(result[i]==undefined){
            result[i]=0;
        }
    }
    return result
};
```



**完成「力扣」第 496 题：下一个更大元素 I；**

```javascript
var nextGreaterElement = function(nums1, nums2) {
    let stack=[];
    let map={}
    for(let i=0;i<nums2.length;i++){
        if(stack.length==0){
            stack.push(nums2[i])
        }else{
            if(stack[stack.length-1]>=nums2[i]){
                stack.push(nums2[i])
            }else{
                while(stack[stack.length-1]<nums2[i]){
                    let pop=stack.pop();
                    map[pop]=nums2[i]
                }
                stack.push(nums2[i]);
            }
        }
    }
    let result=[];
    for(let i=0;i<nums1.length;i++){
        if(map[nums1[i]]){
            result[i]=map[nums1[i]]
        }else{
            result[i]=-1
        }
    }

    return result;
};
```



**完成「力扣」第 503 题：下一个更大元素 II；**

```javascript
var nextGreaterElements = function(nums) {
    let stack=[];
    let map={};
    let find=[];
    let unfind=[];
    //正向遍历
    for(let i=0;i<nums.length;i++){
        if(stack.length==0){
            stack.push(i);
        }else{
            while(nums[stack[stack.length-1]]<nums[i]){
                let pop=stack.pop();
                map[pop]=nums[i];
                find.push(pop);
            }
            stack.push(i);
        }
    }
    //遍历栈中
    for(let i=0;i<stack.length;i++){
        unfind.push(stack[i]);
    }
    let newNums=unfind.concat(find);
    stack=[];
    //再次遍历
    for(let i=0;i<newNums.length;i++){
        let index=newNums[i];
        if(stack.length==0){
            stack.push(index);
        }else{
            while(nums[stack[stack.length-1]]<nums[index]){
                let pop=stack.pop();
                if(!map[pop]){
                    map[pop]=nums[index];
                }
            }
            stack.push(index);
        }
    }

    let result=[];
    for(let i=0;i<nums.length;i++){
        if(map[i]){
            result[i]=map[i]
        }else{
            result[i]=-1
        }
    }

    return result;
};
```

**完成「力扣」第 84 题：柱状图中最大的矩形；**





### 队列：先进先出的数据结构

**双端队列**

双端队列是可以在线性表的两端都支持 O(1)*O*(1) 操作的队列。



**优先队列**

优先队列是在计算机领域非常重要的一种数据结构。优先队列组织数据的形式是**树**，但它是存在数组中的。



### 典型问题 1：用栈实现队列、用队列实现栈

**例 1 ：「力扣」第 232 题：用栈实现队列。**

```javascript
var MyQueue = function() {
    this.stack_push=[];
    this.stack_pop=[];
};

/** 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    this.stack_push.push(x);
    if(this.stack_pop.length==0){
        while(this.stack_push.length>0){
            this.stack_pop.push(this.stack_push.pop());
        }
    }
};

/**
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    let pop=this.stack_pop.pop();
    if(this.stack_pop.length==0){
        while(this.stack_push.length>0){
            this.stack_pop.push(this.stack_push.pop());
        }
    }
    return pop;
};

/**
 * @return {number}
 */
MyQueue.prototype.peek = function() {
    let peek=this.stack_pop[this.stack_pop.length-1];
    return peek
};

/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    if(this.stack_pop.length==0&&this.stack_push.length==0){
        return true;
    }else{
        return false;
    }
};
```



**例 2：「力扣」第 225 题：用队列实现栈**

```javascript
var MyStack = function() {
    this.queue_push=[];
    this.queue_pop=[];
};

/** 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    this.queue_push.push(x);
    while(this.queue_push.length>0){
        this.queue_pop.push(this.queue_push.shift());
    }

};

/**
 * @return {number}
 */
MyStack.prototype.pop = function() {
    let pop=this.queue_pop.pop();
    while(this.queue_push.length>0){
        this.queue_pop.push(this.queue_push.shift());
    }
    return pop;
};

/**
 * @return {number}
 */
MyStack.prototype.top = function() {
    return this.queue_pop[this.queue_pop.length-1];
};

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    if(this.queue_pop.length==0&&this.queue_push.length==0){
        return true;
    }else{
        return false;
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */
```



**练习 完成「力扣」第 151 题：[最小栈](https://leetcode-cn.com/problems/min-stack/)。**

```javascript
var MinStack = function() {
    this.stack=[];
    this.minQueue=[];
};

/** 
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function(val) {
    //普通栈
    this.stack.push(val);
    //最小栈
    if(this.minQueue.length==0){
        this.minQueue.push(val);
    }else{
        if(val<=this.minQueue[this.minQueue.length-1]){
            this.minQueue.push(val);
        }else{
            this.minQueue.unshift(val);
        }
    };
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    let pop=this.stack.pop();
    for(let i=this.minQueue.length-1;i>=0;i--){
        if(this.minQueue[i]==pop){
            this.minQueue.splice(i,1);
            break;
        }
    }
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.stack[this.stack.length-1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function() {
    return this.minQueue[this.minQueue.length-1];
};

let stack=new MinStack();
stack.push(-2);
stack.push(0);
stack.push(-1);

console.log(stack)

console.log(stack.getMin())
```



### 典型问题 2：设计循环队列、设计循环双端队列

**例题：设计循环队列**



**例题：设计循环双端队列**



### 典型问题 3：单调队列











# 8. 优先队列

### 优先队列与堆

总结
优先队列不同于普通的队列：

**普通队列**：按照时间顺序出队，先进先出，后进后出；
**优先队列**：出队顺序与入队顺序无关，按照元素的优先级顺序出队。

请重点理解下面的内容，特别重要：

**优先队列的应用场景**：在 动态变化 的数据集合里选出优先级最高的元素，因此没有必要维护所有的元素的大小关系；
为了避免线性扫描，因此将数据组织成 树形结构；
优先队列的高效实现是堆，堆是一个完全二叉树，因此 可以存储在数组里，并且父亲结点和孩子结点可以很方便地互相访问；
堆只需要维护了 局部顺序，时间复杂度更低。

**实现**

```javascript
//二叉堆
function BinaryHeap(arr) {
    this.data=[...arr];
    this.size=this.data.length;
}

BinaryHeap.prototype.maxHeapify=function(i) {
    let max=i;
    if(i>=this.size){
        return false;
    }
    //当前序号左节点
    const l=i*2+1;
    //当前序号右节点
    const r=i*2+2;

    //求当前节点左右节点三者的最大值
    if(l<this.size && this.data[l]>this.data[max]){
        max=l;
    }
    if(r<this.size && this.data[r]>this.data[max]){
        max=r;
    }

    //如果max节点等于本身，则满足最大堆性质
    if(max==i){
        return;
    }

    //父节点与最大节点做交换
    [this.data[max],this.data[i]]=[this.data[i],this.data[max]];

    //递归向下继续执行
    return this.maxHeapify(max);
}


BinaryHeap.prototype.rebuildHeap=function() {
    //获取叶子节点
    const L=Math.floor(this.size / 2);
    for(let i=L-1;i>=0;i--){
        this.maxHeapify(i);
    }
}

BinaryHeap.prototype.isHeap=function() {
    const L=Math.floor(this.size / 2);
    for(let i=L-1;L>=0;i--){
        const l=this.data[2*i+1];
        const r=this.data[2*i+2];

        const max=Math.max(this.data[i],l,r);
        if(max!==this.data[i]){
            return false;
        }
        return true;
    }
}

BinaryHeap.prototype.insert=function(key) {
    //数组末尾插入
    this.data[this.size]=key;
    this.size++;
    if(this.isHeap()){
        return;
    }
    this.rebuildHeap();
}

BinaryHeap.prototype.remove=function(index) {
    if(index>this.size){
        return ;
    }
    this.data.splice(index,1);
    this.size--;
    if(this.isHeap()){
        return;
    }
    this.rebuildHeap();
}

let heap= new BinaryHeap([34,23,1,3,42,13,6]);
heap.rebuildHeap();
heap.remove(0)

console.log(heap);
```



### 堆排序



### 典型问题 1：合并 K 个排序链表

**例题：合并 K 个排序链表**

**练习：设计推特**





### 典型问题 2：top K 问题

**例题：数组中的第 K 个最大元素**

**练习：前 K 个高频元素**

**练习：数据流的中位数**

**练习：根据字符出现频率排序**

**练习：接近原点的 K 个点**

**练习：天际线问题**







# 9. 并查集

简单实现

```javascript

function quick_union() {
    this.cache=[];
}
quick_union.prototype.init=function(len) {
    for(let i=0;i<len;i++){
        this.cache[i]=-1;
    }
}

quick_union.prototype.unit=function(index_1,index_2) {
    if(this.cache[index_1]==-1&&this.cache[index_2]==-1){
        this.cache[index_2]+=this.cache[index_1];
        this.cache[index_1]=index_2;
        return true
    };
    
    return false;
}

quick_union.prototype.isConnect=function(index_1,index_2) {
    //index_1 -> index_2;
    let temp_1=index_1;
    let temp_2=index_2;
    while (this.cache[temp_1]>=0) {
        if(this.cache[temp_1]==index_2){
            return true;
        }
        temp_1=this.cache[temp_1];
    }
    //index_2 -> index_1
    while (this.cache[temp_2]>=0) {
        if(this.cache[temp_2]==index_1){
            return true;
        }
        temp_2=this.cache[temp_2];
    }
    //return false
    return false;
}
quick_union.prototype.find=function(index) {
    return this.cache[index];
}
```



**练习：朋友圈**

```javascript
var findCircleNum = function(isConnected) {
    let map=[];
    for(let i=0;i<isConnected.length;i++){
        for(let j=0;i<isConnected.length;j++){
            if(i!=j){
                if(isConnected[i][j]==1){
                    map.push([i,j]);
                }
            }
        }
    }
    let union = new quick_union();
    union.init(isConnected.length);
    for(let i=0;i<map.length;i++){
        union.union(map[i][0],map[i][1]);
    }
    let result= union.get();
    return result

};

function quick_union(){
    this.cache=[];
}

quick_union.prototype.init=function(len){
    for(let i=0;i<len;i++){
        this.cache.push(-1);
    }
}

quick_union.prototype.union=function(left,right){
    let temp= isConnected[left];
    isConnected[left]=right;
    let count=0;
    while(isConnected[right]>=0){
        right=isConnected[right];
        count++;
        if(count>=this.cache.length){
            return;
        }
    }
    isConnected[right]+=temp;
}

quick_union.prototype.get=function(){
    let result=0;
    for(let i=0;i<this.cache.length;i++){
        if(this.cache[i]==-1){
            result++;
        }
    }
    if(result==this.cache.length){
        return result;
    }else{
        return result+1;
    }
}

console.log(findCircleNum([[1,1,0],[1,1,0],[0,0,1]]))
```





### quick-union 实现优化 1：按秩合并

###### 1. 按size合并

节点数少的合并到节点数多的节点

###### 2. 按阶合并

节点链深度小的向深度大的节点链合并



### 路径压缩的思路 2：完全压缩

「完全压缩」的意思是：让查询根结点的过程中，沿途经过的 **所有结点** 指向都指向根结点。





# 10. 二叉树

深度优先遍历由于其本身的特性，在面对巨大的结果集的时候，能够使用较少的性能消耗，它的另一个名字叫 **回溯算法** 

**完全二叉树**

**满二叉树**



**练习**

**二叉树的层序遍历**

```javascript
var levelOrder = function(root) {
    let cache=[];
    let result=[];
    if(typeof root !== 'object'){
        return new Error('root must be a node');
    }
    //init 
    cache.push(root)
    while(cache.length>0){
        let len=cache.length;
        let temp_result=[];
        for(let i=0;i<len;i++){
            let pop=cache.shift();
            temp_result.push(pop.value);
            if(pop.left){
                cache.push(pop.left);
            };
            if(pop.right){
                cache.push(pop.right);
            };
        }
        result.push(temp_result);
    }
    
    return result;
};


let root={
  value:1,
  left:{
    value:2,
    left:{
      value:4,
      left:null,
      right:null
    },
    right:{
      value:5,
      left:null,
      right:null
    }
  },
  right:{
    value:3,
    left:null,
    right:{
      value:10,
      left:null,
      right:null
    }
  }
}

console.log(levelOrder(root));
```

**完成「力扣」第 107 题：二叉树的层次遍历 II（简单）；**



```javascript
var levelOrder = function(root) {
    let cache=[];
    let result=[];
    if(typeof root !== 'object'){
        return new Error('root must be a node');
    }
    //init 
    cache.push(root)
    while(cache.length>0){
        let len=cache.length;
        let temp_result=[];
        for(let i=0;i<len;i++){
            let pop=cache.shift();
            temp_result.push(pop.value);
            if(pop.left){
                cache.push(pop.left);
            };
            if(pop.right){
                cache.push(pop.right);
            };
        }
        result.unshift(temp_result);
    }
    
    return result;
};
```



**完成《剑指 Offer》第 32 - I 题：从上到下打印二叉树（中等）；**

```javascript
var levelOrder = function(root) {
    let cache=[];
    let result=[];
    if(root==null) return [];
    //init
    cache.push(root);
    while(cache.length>0){
        let shift=cache.shift();
            result.push(shift.value)
        if(shift.left!=null){
            cache.push(shift.left);
        }
        if(shift.right!=null){
            cache.push(shift.right);
        }
    }
    return result;
};
```



**完成《剑指 Offer》第 32 - III 题：从上到下打印二叉树 III（中等）；**

```
//需要记录层数（深度）
//奇数层反转temp_result;

```

**完成「力扣」第 103 题：二叉树的锯齿形层次遍历（中等）。**



### 深度遍历

由于递归方式很简单，所以不在赘述

```javascript
var levelOrder = function(node) {
  let result = [];
  if(node==null) return result;
  let depth=function(node) {
    if(node!=null){
      //前序
      result.push(node.value);
      depth(node.left);
      depth(node.right);
        
      //中序
      //depth(node.left);
      //result.push(node.value);
      //depth(node.right);
        
      //后序
      //...
    }
  }
  depth(node)
  return result;
};
```



非递归实现

```
利用队列/栈实现
逆时针，记录是否出过栈

前序：
出栈（中）-> 左 -> 右

中序：
 右-> 出栈（中）-> 左 

后序：
。。。。

```



**完成「力扣」第 100 题：相同的树（简单）**



**完成「力扣」第 101 题：对称二叉树（简单）**
**完成「力扣」第 199 题：二叉树的右视图（中等）**
**完成「力扣」第 226 题：翻转二叉树（简单）**
**完成「力扣」第 110 题：平衡二叉树（简单）**
**完成「力扣」第 104 题：二叉树的最大深度（简单）**
**完成「力扣」第 111 题：二叉树的最小深度（简单）**

**完成「力扣」第 112 题：路径总和（简单）**
**完成「力扣」第 129 题：求根到叶子节点数字之和（中等）**
**完成「力扣」第 222 题：完全二叉树的节点个数（中等）**
**完成「力扣」第 124 题：二叉树中的最大路径和（困难）**



